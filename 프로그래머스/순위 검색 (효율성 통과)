#include <string>
#include <vector>
#include <sstream>
#include <map>
using namespace std;
// map과 이분 탐색을 이용.
// map은 조건을 key, 점수를 value로 구성한다.

/*
1) info를 파싱하는데, -를 포함한 모든 경우의 수를 map에 넣어준다. query에서 나올 수 있는 조건을 모두 map에 넣어주면 된다. 2^4 = 16 이기 때문에 시간초과는 걱정하지 않아도 된다.

ex) "javabackendjuniorpizza"가 파싱 결과라면, "-backendjuniorpizza", "--juniorpizza", "---pizza"...

 

2) map을 순회하면서 점수를 오름차순으로 정렬해준다. 이분 탐색을 위해 정렬이 필요하다.

 

3) query를 파싱하여 조건을 나타내는 문자열을 얻는다.

만약 query[0]의 파싱 결과가 "--senior-" 라면 map에서 해당 문자열을 찾아 점수를 확인한다.

점수는 이분탐색을 통해 찾으며, lower_bound() 함수를 이용해 파싱한 점수보다 작지 않은 값 중 가정 첫 번째 위치를 가져온다.

그리고 answer[i]에 답을 넣어주면 된다.
*/

/*
1. info 에 대해 모든 가능한 경우의 수 구하기.
2. map key를 조건, value를 점수로 해 점수를 기준으로 정렬하기
*/


vector<int> solution(vector<string> info, vector<string> query) {
    vector<int> answer(query.size(), 0);
    map<string, vector<int>> m;

    for(int i=0; i<info.size(); i++){
        int score = 0, idx = 0;
        vector<vector<string>> v(4, vector<string>(2, "-"));
        string str;
        stringstream ss(info[i]);
        while(ss >> str){
            if(idx==4){
                score = stoi(str);
            }
            else {
                v[idx++][0] = str;
            }
        }
        

        //info의 모든 경우의 수 map
        for(int a = 0; a<v[0].size(); a++){
            string s1, s2, s3, s4;
            s1 = v[0][a];
            for(int b = 0; b<v[1].size(); b++){
                s2 = v[1][b];
                for(int c = 0; c<v[2].size(); c++){
                    s3 = v[2][c];
                    for(int d = 0; d<v[3].size(); d++){
                        s4 = v[3][d];
                        m[s1 + s2 + s3 + s4].push_back(score);
                    }
                }    
                
                    
            }
            
            
        }
        
    }
    
    return answer;
}
